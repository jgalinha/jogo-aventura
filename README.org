#+TITLE: Adventure Game (Jogo Aventura - ja)
#+AUTHOR: José Galinha
#+EMAIL: jbgalinha@gmail.com
#+DATE: Thu Jan  7 12:12:33 2021
#+DESCRIPTION: Adventure Game createad for the TG2 of discipline of Sistemas Operativos
#+PROPERTY: header-args:C :tangle ja.c :mkdirp yes :main no :cache yes

<- [[file:~/personal/estig/SistemasOperativos.org][Back to Sistemas Operativos]]

* Makefile

Criação de makefile para compilação do código, tornando mais fácil o processo de devenvolvimento

#+BEGIN_SRC makefile :tangle makefile :cache yes
all: ja

ja: ja.c
	gcc ja.c -o ja

clean: rm ja *.o
#+END_SRC
 

* Comentario Incial e =includes=

#+CAPTION: Comentario Incial e =includes=
#+BEGIN_SRC C +n

/*****************************************************************************/
/*                  TG2 - Adventure Game(ja - jogo aventura)                 */
/* Author: José Galinha ******************************************************/
/* Email: jbgalinha@gmai.com *************************************************/
/*****************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#+END_SRC

* Constantes e Vairáveis

Definiçao de variaveis e constantes a usar no codigo

#+CAPTION: Constantes e Variaveis
#+BEGIN_SRC C +n

#define MAX_NAME 50 /* Maximum name length */ 
#define MAX_OBJECT_NAME 10 /* Maximum object name lenght */
#define MAX_TEXT_ROOM_DESCRIPTION 500 /* Maximum lenght for the room description */
#define MAX_ROOMS 100 /* Maximum rooms in each map */
#define INITIAL_ENERGY_PLAYER 100 /* Default start player energy */
#define INITIAL_PLAYER_LOCATION 0 /* Defaule start player location */
#define NONE -1 /* Constant do start empty things */

short int su = 0; /* Varriável para controlar o SuperUser */
short int nRoomMap; /* Number of rooms in the map */

#+END_SRC

* Estrutura =Player=

#+BEGIN_SRC C +n

/* Player Structure */
struct Player {
    char name[MAX_NAME];
    short int energy;
    short int location;
    short int object;
    short int treasure;
};

#+END_SRC

* Estrutura =Room=

#+BEGIN_SRC C +n

/* Room Structure */
struct Room {
    short int north;
    short int south;
    short int east;
    short int west;
    short int up;
    short int down;
    short int object;
    short int treasure;
    char description[MAX_TEXT_ROOM_DESCRIPTION];
};

#+END_SRC

* Estrutura =Objecto=

Definiçao da estrutura do objecto:
- name: nome do objecto
- power: nivel do poder na luta

#+CAPTION: Estrutura do objecto
#+BEGIN_SRC C +n
/* Object Structure */
struct Object {
    char name[MAX_OBJECT_NAME];
    short int power;
};
#+END_SRC

* Estrutura =Monstro=

Definação da estrutura do monstro:
- energy: energia inicial do monstro
- location: localização inicial do monstro

#+CAPTION: Estrutura do monstro
#+BEGIN_SRC C +n
/* Monster Structure */
struct Monster {
    short int energy;
    short int location;
};
#+END_SRC

* Declaração de funções

#+BEGIN_SRC C +n

/* Player Functions **********************************************************/
void PlayerInit(struct Player *pPlayer); 
void PlayerStats(struct Player player);
/* Map Functions *************************************************************/
short int InitDefaultMap(struct Room *pMap); 
void RoomInit(struct Room *pRoom, short int north, short int south,
              short int east, short int west, short int up, short int down,
              short int object, short int treasure,
              char description[MAX_TEXT_ROOM_DESCRIPTION]);
/* Object Functions **********************************************************/
short int ObjectsInit(struct Object *pObjects[]); 
void ObjectInit(struct Object *pObject, char name[MAX_OBJECT_NAME],
                short int power); 
short int DefaultObjectsInit(struct Object *pObject); 
/* Monster Functions *********************************************************/
void MonsterInit (struct Monster *pMonster, short int energy,
                  short int location); 
/* Super User Functions ******************************************************/
void SuperUserInit(int argc, char *argv[], struct Player *pPlayer);
/*****************************************************************************/

#+END_SRC

* Função =main=

#+BEGIN_SRC C +n

int main(int argc, char *argv[]) {

    
    struct Player player;
    struct Room map[MAX_ROOMS];
    struct Object objects[MAX_ROOMS];
    struct Monster monster;
    short int nObjects;
    /* Player Initializations */
    PlayerInit(&player);
    /* Object Initialization */
    DefaultObjectsInit(objects);
    /* Map Initialization */
    nRoomMap = InitDefaultMap(map);
    /* Monster Initialization */
    MonsterInit(&monster, 100, -1);
    
    if (argc > 1)
        SuperUserInit(argc, argv, &player);

    PlayerStats(player);
    
    return 0;
}

#+END_SRC

#+RESULTS:

* Funções do =player=

#+BEGIN_SRC C +n

/*****************************************************************************/
/*                              Player Functions                             */
/*****************************************************************************/

/* Function to init the player */
void PlayerInit(struct Player *pPlayer) { // (ref:PlayerInit)
    printf("Qual o seu nome aventureiro? \n -> ");
    scanf("%s", (*pPlayer).name);
    (*pPlayer).energy = INITIAL_ENERGY_PLAYER;
    (*pPlayer).location = INITIAL_PLAYER_LOCATION;
    (*pPlayer).object = NONE; 
    (*pPlayer).treasure = NONE;
    printf("\nBoa Sorte %s! Vai precisar...\n", (*pPlayer).name);
}

/* Function to show the player stats */
void PlayerStats(struct Player player) {
    printf("*** Player %s Stats ***\n", player.name);
    printf("Energy: %hd\n", player.energy);
    printf("Location: %hd\n", player.location);
    printf("Object: %hd\n", player.object);
}

#+END_SRC
* Funções do =map=

#+BEGIN_SRC C +n

/*****************************************************************************/
/*                               Map Functions                               */
/*****************************************************************************/

/* Function to initialize one default map ************************************/
short int InitDefaultMap(struct Room *pMap) {
    /* TODO Create the default map layout */
    RoomInit(&pMap[0], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste1");
    RoomInit(&pMap[1], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[2], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[3], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[4], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[5], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[6], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[7], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[8], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste3");
    RoomInit(&pMap[9], 1, 1, 1, 1, NONE, NONE, 1, 1, "Teste9");

    return 10;
}

void MapInit(struct Room *pMap[]){

    /* Devolver o número de sala em cada mapa */
}

/* Function to init the map rooms */
void RoomInit(struct Room *pRoom, short int north, short int south,
              short int east, short int west, short int up, short int down,
              short int object, short int treasure,
              char description[MAX_TEXT_ROOM_DESCRIPTION]){

    pRoom->north = north;
    pRoom->south = south;
    pRoom->east = east;
    pRoom->west = west;
    pRoom->up = up;
    pRoom->down = down;
    pRoom->object = object;
    pRoom->treasure = treasure;
    strcpy(pRoom->description, description);
    
}


#+END_SRC

* Funções do =objecto=

** ObjectsInit

Inicia o vector de objectos disponíves ao jogador, a função devolver um inteiro
com o número objectos disponíves

#+CAPTION: ObjectsInit
#+BEGIN_SRC C +n
/* Function to initialize de objects vector */
short int ObjectsInit(struct Object *pObjects[]) {
    return 0;
}
#+END_SRC

** ObjectInit

Função para criar os objectos do jogo, à função é passado um apontador de um
objecto para definir os seus dados.

#+CAPTION: ObjectInit
#+BEGIN_SRC C +n
/* Function to initialize an object */
void ObjectInit(struct Object *pObject, char name[MAX_OBJECT_NAME],
                short int power) {
    strcpy(pObject->name, name);    
    pObject->power = power;
}
#+END_SRC

** DefaultObjectsInit

Função que inicia um conjunto de objectos por defeito, a seu usado em caso
de erro no carregamento do ficheiro de configurações

#+CAPTION: DefaultObjectsInit
#+BEGIN_SRC C +n
/* Function to initialize the default objects vector */
short int DefaultObjectsInit(struct Object *pObject) {
    ObjectInit(&pObject[0], "faca", 5);
    ObjectInit(&pObject[1], "espada", 20);
    ObjectInit(&pObject[2], "escudo", -10);
    ObjectInit(&pObject[3], "sopa", -3);
    ObjectInit(&pObject[4], "alabarda", 35);
    ObjectInit(&pObject[5], "machado", 45);
    ObjectInit(&pObject[5], "besta", 20);
    ObjectInit(&pObject[6], "poção mágica", -80);

    return 7;
}
#+END_SRC
    
* Funções do =monstro=

** TODO MonsterInit [0%]

- [ ] Arranjar alternativa para o rand, está lento

Função para iniciar o monstro no mapa, à função é passado um apontador do
monstro para definir os seus dados iniciais

- *pMonster: apontador que recebe o monstro
- energy: nível de energia do monstro
- location: localização do monstro no mapa, quando passado o valor -1 cria
  o monstro numa localização aleatória

A função usa o ~srand~ para iniciar um =generator= para o ~rand~

#+CAPTION: MonsterInit
#+BEGIN_SRC C +n
void MonsterInit (struct Monster *pMonster, short int energy,
                  short int location) {
    
    time_t t;
    
    pMonster->energy = energy;
    if (location == -1 || location > nRoomMap) {
        do {
            /* Intializes random number generator */
            srand((unsigned) time(&t));
            location = rand() % nRoomMap;
        } while (location <= 1);
    } 
    pMonster->location = location;
}
#+END_SRC

* Funções do =Super User=

** SuperUserInit

Função para iniciar o modo super user, a função recebe o numero de argumentos asssim como o vector de argumentos e o apontador para a estrutura do player.

Seguidamente a função verifica se o códio intruduzido no primeiro argumento é válido, definindo após os valores passados, caso sejam passados, não sendo necssário passar todos os valores, sendo que na sua omissão são usados os valores por defeito.

A função recebe os seguintes valores por ordem:
- Código de Super User
- Energia do jogador
- Localização do jogador
- Objecto a transportar

#+CAPTION: SuperUserInit
#+BEGIN_SRC C +n
void SuperUserInit(int argc, char *argv[], struct Player *pPlayer){
    if ( atoi(argv[1]) == 1765 ){
        // verifica se o parametro da energia foi passado
        if ( argc > 2 ) 
            // verifica se o paramametro passado é possivel de converter para short inteiro
            // se for define, caso contrario usa o valor por defeito
            pPlayer->energy = ((short)atoi(argv[2]) > 0) ? (short)atoi(argv[2]) : pPlayer->energy;
        // verifica se o parametro da localização foi passado
        if ( argc > 3 )
            // verifica se o paramametro passado é possivel de converter para short inteiro
            // se for define, caso contrario usa o valor por defeito
            pPlayer->location = ((short)atoi(argv[3]) > 0) ? (short)atoi(argv[3]) : pPlayer->location;
        // verifica se o parametro do objecto foi passado
        if ( argc > 4 )
            // verifica se o paramametro passado é possivel de converter para short inteiro
            // se for define, caso contrario usa o valor por defeito
            pPlayer->object = ((short)atoi(argv[3]) > 0) ? (short)atoi(argv[3]) : pPlayer->object;
        su = 1;
        printf("MODO SUPER USER ATIVO\n");
    }
}
#+END_SRC

